---
alwaysApply: true
---

# ğŸ“œ XSD/XML - Fuente Ãšnica de Verdad

## ğŸ¯ REGLA FUNDAMENTAL
**"Todo XML y TypeScript debe derivar EXCLUSIVAMENTE del XSD. No inventar campos."**

## ğŸ”„ Flujo de Trabajo

1. ğŸ“ Modificar `schema.xsd`
2. ğŸ”§ Generar interfaces: `npm run generate:types`
3. âœ… Validar: `npm run validate:xml`
4. ğŸ§ª Testear: `npm run test:schemas`
5. ğŸ”„ Commit con XSD + interfaces generadas

## ğŸ“Š GeneraciÃ³n de Interfaces

```typescript
// XSD:
// <xs:element name="Invoice">
//   <xs:complexType>
//     <xs:sequence>
//       <xs:element name="Id" type="xs:string"/>
//       <xs:element name="Amount" type="xs:decimal"/>
//       <xs:element name="Currency" type="CurrencyCode"/>
//     </xs:sequence>
//   </xs:complexType>
// </xs:element>

// TypeScript generado automÃ¡ticamente:
interface Invoice {
  Id: string;
  Amount: number;
  Currency: 'USD' | 'EUR' | 'GBP'; // Del simpleType en XSD
}

// âŒ PROHIBIDO: Campos que no existen en XSD
interface Invoice {
  Id: string;
  Amount: number;
  Currency: string;
  CreatedAt?: Date; // âŒ NO EXISTE EN XSD
}
```

## âœ… ValidaciÃ³n en Runtime

```typescript
import { Validator } from 'xsd-schema-validator';
import { z } from 'zod';

// 1. Validar contra XSD
async function validateXml(xml: string, xsdPath: string) {
  return new Promise((resolve, reject) => {
    Validator.validateXML(xml, xsdPath, (err, result) => {
      if (err) reject(err);
      resolve(result);
    });
  });
}

// 2. Validar con Zod (segunda capa)
const InvoiceSchema = z.object({
  Id: z.string().min(1),
  Amount: z.number().positive(),
  Currency: z.enum(['USD', 'EUR', 'GBP']),
});

// 3. FunciÃ³n completa
async function parseInvoice(xmlString: string): Promise<Invoice> {
  // Paso 1: Validar estructura XML
  const xsdResult = await validateXml(xmlString, './schemas/invoice.xsd');
  if (!xsdResult.valid) {
    throw new XsdValidationError('Invalid XML structure', xsdResult.errors);
  }
  
  // Paso 2: Parsear a objeto
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlString, 'text/xml');
  
  const invoice = {
    Id: xmlDoc.getElementsByTagName('Id')[0]?.textContent,
    Amount: xmlDoc.getElementsByTagName('Amount')[0]?.textContent,
    Currency: xmlDoc.getElementsByTagName('Currency')[0]?.textContent,
  };
  
  // Paso 3: Validar tipos con Zod
  const validated = InvoiceSchema.safeParse(invoice);
  if (!validated.success) {
    throw new ValidationError('Type validation failed', validated.error);
  }
  
  return validated.data;
}
```

## ğŸ› ï¸ Herramientas de Desarrollo

```json
// package.json
{
  "scripts": {
    "generate:types": "xsd-ts ./schemas/*.xsd --output ./src/types/xsd-generated.ts",
    "validate:xml": "node scripts/validate.js ./test-data/*.xml",
    "test:schemas": "jest --testPathPattern=.*schema.test.ts"
  },
  "devDependencies": {
    "xsd-ts": "^1.0.0",
    "xsd-schema-validator": "^0.7.0",
    "fast-xml-parser": "^4.0.0",
    "zod": "^3.0.0"
  }
}
```

## ğŸ§ª Testing

```typescript
// tests/xsd-validation.test.ts
describe('XSD Validation', () => {
  test('Invoice XML vÃ¡lido', async () => {
    const xml = `
      <Invoice xmlns="http://example.com/ns">
        <Id>INV-001</Id>
        <Amount>100.50</Amount>
        <Currency>USD</Currency>
      </Invoice>
    `;
    
    const result = await validateXml(xml, './schemas/invoice.xsd');
    expect(result.valid).toBe(true);
  });
  
  test('Rechaza campo no definido', async () => {
    const xml = `
      <Invoice>
        <Id>INV-001</Id>
        <Amount>100.50</Amount>
        <Currency>USD</Currency>
        <ExtraField>123</ExtraField> <!-- âŒ NO EXISTE -->
      </Invoice>
    `;
    
    const result = await validateXml(xml, './schemas/invoice.xsd');
    expect(result.valid).toBe(false);
  });
});

// tests/types-match.test.ts
test('TypeScript interface matches XSD', () => {
  const xsdFields = ['Id', 'Amount', 'Currency'];
  const tsFields = Object.keys({} as Invoice);
  
  // Todos los campos XSD deben estar en TypeScript
  xsdFields.forEach(field => {
    expect(tsFields).toContain(field);
  });
  
  // TypeScript no debe tener campos extras
  tsFields.forEach(field => {
    expect(xsdFields).toContain(field);
  });
});
```

## âš ï¸ Manejo de Errores

```typescript
class XsdValidationError extends Error {
  constructor(
    message: string,
    public readonly validationErrors: Array<{
      line: number;
      column: number;
      message: string;
    }>
  ) {
    super(`XSD Validation Failed: ${message}`);
    this.name = 'XsdValidationError';
  }
}

// Recovery parcial
function safeXmlParse(xml: string) {
  try {
    return { success: true, data: parseInvoice(xml) };
  } catch (error) {
    if (error instanceof XsdValidationError) {
      // Log detallado para debugging
      console.error('XSD Errors:', error.validationErrors);
      
      // Intentar extraer datos parciales
      const partial = extractPartialData(xml);
      return { 
        success: false, 
        error: error,
        partialData: partial 
      };
    }
    throw error;
  }
}
```

## ğŸ”— Namespaces y Versiones

```typescript
// Namespaces obligatorios
const XML_NAMESPACES = {
  v1: 'http://example.com/ns/v1',
  v2: 'http://example.com/ns/v2',
  xsi: 'http://www.w3.org/2001/XMLSchema-instance',
};

// Incluir en XML generado
function generateXml(invoice: Invoice, version: 'v1' | 'v2' = 'v1'): string {
  return `
    <Invoice 
      xmlns="${XML_NAMESPACES[version]}"
      xmlns:xsi="${XML_NAMESPACES.xsi}"
      xsi:schemaLocation="${XML_NAMESPACES[version]} ./schemas/invoice-${version}.xsd"
    >
      <Id>${escapeXml(invoice.Id)}</Id>
      <Amount>${invoice.Amount.toFixed(2)}</Amount>
      <Currency>${invoice.Currency}</Currency>
    </Invoice>
  `;
}

// Detectar versiÃ³n
function detectXmlVersion(xml: string): 'v1' | 'v2' {
  if (xml.includes(XML_NAMESPACES.v2)) return 'v2';
  return 'v1';
}
```

## ğŸš¨ REGLA FINAL
**El XSD es ley. Todo cambio en datos XML comienza modificando el XSD.**
