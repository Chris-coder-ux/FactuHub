---
alwaysApply: true
---

# ğŸ§ª Testing - Reglas y Patrones

## ğŸ¯ PRINCIPIOS FUNDAMENTALES

1. **Cobertura mÃ­nima**: >80% para cÃ³digo crÃ­tico
2. **Tests descriptivos**: Nombres que explican quÃ© y por quÃ©
3. **AAA Pattern**: Arrange, Act, Assert
4. **Tests aislados**: No dependencias entre tests
5. **Mocks apropiados**: Solo cuando es necesario

## ğŸ“‹ Estructura de Tests

```typescript
// âœ… CORRECTO
describe('InvoiceService', () => {
  describe('createInvoice', () => {
    it('debe crear una factura vÃ¡lida con todos los campos requeridos', async () => {
      // Arrange
      const invoiceData = {
        clientId: 'client-123',
        amount: 1000,
        currency: 'EUR',
      };
      
      // Act
      const result = await invoiceService.createInvoice(invoiceData);
      
      // Assert
      expect(result).toHaveProperty('id');
      expect(result.amount).toBe(1000);
      expect(result.status).toBe('pending');
    });
    
    it('debe rechazar facturas con amount negativo', async () => {
      // Arrange
      const invalidData = { amount: -100 };
      
      // Act & Assert
      await expect(
        invoiceService.createInvoice(invalidData)
      ).rejects.toThrow('Amount must be positive');
    });
  });
});
```

## ğŸš« PROHIBIDO

```typescript
// âŒ Tests sin descripciÃ³n clara
it('works', () => { /* ... */ });

// âŒ Tests que dependen de otros
it('test 2', () => {
  // Depende de test 1
  expect(globalState).toBe('modified');
});

// âŒ Tests que no limpian despuÃ©s
it('creates user', async () => {
  await createUser({ name: 'Test' });
  // âŒ No limpia la base de datos
});
```

## âœ… PATRONES OBLIGATORIOS

### Jest - Unit Tests

```typescript
// Setup y teardown
describe('Feature', () => {
  beforeEach(() => {
    // Setup antes de cada test
  });
  
  afterEach(() => {
    // Limpieza despuÃ©s de cada test
  });
  
  beforeAll(() => {
    // Setup una vez antes de todos
  });
  
  afterAll(() => {
    // Limpieza una vez despuÃ©s de todos
  });
});

// Mocks
jest.mock('@/lib/api', () => ({
  fetchData: jest.fn(),
}));

// Async tests
it('debe manejar errores de red', async () => {
  const error = new Error('Network error');
  jest.spyOn(api, 'fetchData').mockRejectedValue(error);
  
  await expect(service.getData()).rejects.toThrow('Network error');
});
```

### Testing Library - Component Tests

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

describe('InvoiceForm', () => {
  it('debe mostrar error cuando el formulario estÃ¡ vacÃ­o', async () => {
    // Arrange
    const user = userEvent.setup();
    render(<InvoiceForm />);
    
    // Act
    const submitButton = screen.getByRole('button', { name: /submit/i });
    await user.click(submitButton);
    
    // Assert
    await waitFor(() => {
      expect(screen.getByText(/amount is required/i)).toBeInTheDocument();
    });
  });
  
  it('debe llamar onSubmit con datos vÃ¡lidos', async () => {
    // Arrange
    const onSubmit = jest.fn();
    const user = userEvent.setup();
    render(<InvoiceForm onSubmit={onSubmit} />);
    
    // Act
    await user.type(screen.getByLabelText(/amount/i), '1000');
    await user.click(screen.getByRole('button', { name: /submit/i }));
    
    // Assert
    await waitFor(() => {
      expect(onSubmit).toHaveBeenCalledWith({ amount: 1000 });
    });
  });
});
```

### Cypress - E2E Tests

```typescript
// cypress/integration/invoices.spec.js
describe('Invoice Flow', () => {
  beforeEach(() => {
    cy.login('user@example.com', 'password');
    cy.visit('/invoices');
  });
  
  it('debe crear una nueva factura', () => {
    cy.get('[data-testid="new-invoice-button"]').click();
    cy.get('[name="amount"]').type('1000');
    cy.get('[name="client"]').select('Client 1');
    cy.get('button[type="submit"]').click();
    
    cy.url().should('include', '/invoices');
    cy.contains('Invoice created successfully').should('be.visible');
  });
  
  it('debe mostrar lista de facturas', () => {
    cy.get('[data-testid="invoice-list"]').should('be.visible');
    cy.get('[data-testid="invoice-item"]').should('have.length.at.least', 1);
  });
});
```

## ğŸ” Testing de APIs

```typescript
// app/api/invoices/__tests__/route.test.ts
import { GET, POST } from '../route';
import { NextRequest } from 'next/server';

describe('GET /api/invoices', () => {
  it('debe retornar lista de facturas', async () => {
    const request = new NextRequest('http://localhost/api/invoices');
    const response = await GET(request);
    const data = await response.json();
    
    expect(response.status).toBe(200);
    expect(Array.isArray(data)).toBe(true);
  });
  
  it('debe retornar 401 sin autenticaciÃ³n', async () => {
    const request = new NextRequest('http://localhost/api/invoices');
    // Sin headers de auth
    const response = await GET(request);
    
    expect(response.status).toBe(401);
  });
});
```

## ğŸ›¡ï¸ Testing de ValidaciÃ³n (Zod)

```typescript
import { z } from 'zod';

const InvoiceSchema = z.object({
  amount: z.number().positive(),
  currency: z.enum(['EUR', 'USD']),
});

describe('InvoiceSchema', () => {
  it('debe validar factura correcta', () => {
    const valid = { amount: 1000, currency: 'EUR' };
    expect(() => InvoiceSchema.parse(valid)).not.toThrow();
  });
  
  it('debe rechazar amount negativo', () => {
    const invalid = { amount: -100, currency: 'EUR' };
    expect(() => InvoiceSchema.parse(invalid)).toThrow();
  });
  
  it('debe rechazar currency invÃ¡lida', () => {
    const invalid = { amount: 1000, currency: 'INVALID' };
    expect(() => InvoiceSchema.parse(invalid)).toThrow();
  });
});
```

## ğŸ“Š Performance Testing

```typescript
// Artillery para load testing
// artillery/banking-performance.yml
config:
  target: 'https://api.example.com'
  phases:
    - duration: 60
      arrivalRate: 10
scenarios:
  - name: 'Create Invoice'
    flow:
      - post:
          url: '/api/invoices'
          json:
            amount: 1000
            currency: 'EUR'
```

## ğŸ¯ Coverage Goals

- **Unit Tests**: >80% para servicios y utilidades
- **Integration Tests**: >70% para APIs
- **E2E Tests**: Flujos crÃ­ticos del usuario
- **Edge Cases**: Siempre cubiertos

## ğŸ“ Nomenclatura de Tests

```typescript
// âœ… CORRECTO
describe('InvoiceService', () => {
  it('debe crear factura cuando todos los campos son vÃ¡lidos', () => {});
  it('debe rechazar factura con amount negativo', () => {});
  it('debe calcular IVA correctamente para productos', () => {});
});

// âŒ INCORRECTO
describe('InvoiceService', () => {
  it('test 1', () => {});
  it('works', () => {});
  it('should work', () => {}); // "should" es redundante
});
```

## ğŸš¨ REGLA FINAL
**Cada funciÃ³n pÃºblica debe tener al menos un test. Los tests deben ser legibles, rÃ¡pidos y aislados.**
